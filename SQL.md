# 数据库

## 一、mysql 索引详解

1. 什么是索引

   > 官方介绍索引是帮助MySQL**高效获取数据**的**数据结构**。简单来讲，数据库索引就像是书前面的目录，能**加快数据库的查询速度**。
   >
   > 事实上，索引是一种数据结构，用于帮助我们在**大量数据**中快速定位到我们想要查找的数据。

   但对于海量数据来说，它的目录也是很大的，不可能全部存储在内存中，因此**索引往往是存储在磁盘上的文件中**（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。
   ### 索引的优缺点
   1. 优点：
   - 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
   - 索引可以帮助服务器避免排序和创建临时表
   - 索引可以将随机IO变成顺序IO
   - 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性
   - 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
   - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   - 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
   - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
   - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
   2. 缺点：
     - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
     - 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
     - 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
     - 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
     - 对于非常小的表，大部分情况下简单的全表扫描更高效；

2. 索引的分类

   1. 单列索引

      一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了

      - 普通索引：MySQL中基本<font color=red>索引类型</font>，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。
      - <font color=grayblue>唯一索引</font>：索引列中的值必须是唯一的，但是允许为空值。
      - 主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。

   2. 组合索引

      在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

   3. 全文索引

      全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。
   4. 前缀索引

      所谓前缀索引：<font color=red>`说白了就是对文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快。`</font>这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数
      那么为什么不对整个字段建立索引呢？一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，<font color=red>`前缀索引仅仅是选择一个字段的部分字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性`</font>
      *什么是索引选择性*
      关于索引的选择性，它是指不重复的索引值和数据表的记录总数的比值，取值范围在 [0,1] 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行
      那是不是选择性越高的索引越好呢？当然不是！索引选择性最高为 1，如果索引选择性为 1，就是唯一索引了，搜索的时候就能直接通过搜索条件定位到具体一行记录！这个时候虽然性能最好，但是也是最费空间的，这不符合我们创建前缀索引的初衷
      我们一开始之所以要创建前缀索引而不是唯一索引，`就是希望能够在索引的性能和空间之间找到一个平衡，`我们希望能够选择足够长的前缀以保证较高的选择性（这样在查询的过程中就不需要扫描很多行），但是又希望索引不要太过于占用存储空间
      那么我们该如何选择一个合适的索引选择性呢？`索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数`

        - 首先可过如下 SQL 得到全列选择性
          
            > SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
        - 然后再通过如下 SQL 得到某一长度 prefix_length
            
            > SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
      > 在上面这条 SQL 执行的时候，我们要注意选择合适的 prefix_length，直至计算结果`最接近于`全列选择性的时候，就是最佳结果了，然后使用这个 prefix_length 就可以创建前缀索引了
      > 在前缀索引中 B+Tree 里保存的`根本就不是完整的`表字段的值，必须要回表才能拿到需要的数据。所以，用了前缀索引，就用不了覆盖索引了
      > *创建前缀索引*
            >
            > alter table city_demo add index city_index(city(14));
      
            1. 前缀索引是一种能使索引占用空间更小，查询速度更快的有效办法，但另一方面也有其缺点：mysql 无法使用其前缀索引做 `ORDER BY` 和 `GROUP BY`，用了前缀索引，就用不了覆盖索引了
      2. 要明确使用前缀索引的目的与优势
      
        - 大大节约索引的占用空间，从而提高索引效率
        - 对于 `BOLB 、TEXT `或者很长的 `VARCHAR` 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度
      3.真正的难点在于：<font color=red>`要选择足够长的前缀以保证较高的选择性，同时又不能太长， 前缀的长度应该使前缀索引的选择性接近索引整个列，即前缀的基数应该接近于完整列的基数`</font>
3. 索引的数据结构

   索引的数据结构使用的是B+树，那为什么使用B+树而不是二叉查找树、平衡二叉树或者B树呢，接下来，我们来讲讲B+树的由来。

   ##### 二叉查找树

   它的特点：

   > 1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
   > 2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   > 3. 它的左、右子树也分别为二叉查找树。

   二叉查找树的特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这是我们不想见到的。

   ##### 二叉平衡树

   平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

   使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。

   就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：

   > 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s）
   >
   > 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。

   ##### B树：改造二叉平衡

   对于二叉平衡树，我们更希望出现‘矮胖’树而不是‘瘦高’树，因为这样可以减少查询时的IO操作次数，增加查询效率。那么我们如何能够降低树的高度呢？

   假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）

   因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。

   ![img](https://img-blog.csdnimg.cn/1edcf35f41bd4baf8f8b3a29eab6d548.png)

   这种数据结构我们称为B树，B树是一种多叉平衡查找树，主要特点如下：

   > 1. B树的节点中存储着多个元素，每个内节点有多个分叉。
   > 2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
   > 3. 父节点当中的元素不会出现在子节点中。
   > 4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

   到这里，B树已经是比较理想的了，但我们还有可以优化的地方：

   > B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
   >
   > 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

   ##### B+树：改造B树

   B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于**非叶子节点是否存储数据**的问题

   > - B树：非叶子节点和叶子节点都会存储数据。
   > - B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

   ![img](https://img-blog.csdnimg.cn/8a0e2789eb3b491286cdd287fc89fe23.png)

   B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟这增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。
   ##### HASH索引
   哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
   ![image-20230221202122041](C:\Users\luozh\AppData\Roaming\Typora\typora-user-images\image-20230221202122041.png)

4. MySQL索引的优化

   - 避免回表

     在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？

     使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）

     如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。

     **这就是一个典型的使用覆盖索引的优化策略减少回表的情况。**

   - 联合索引的使用

     联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。

     联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那建议这种情况下使用联合索引。

     **联合索引的使用：**

     > 1. 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
     > 2. 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。

## 优化手段

1. SQL优化

   - 避免SELECT * ，只查询需要的字段。

   - 写完SQL先explain查看执行计划

   - 操作delete或者update语句，加个limit

     - **「降低写错SQL的代价」**, 你在命令行执行这个SQL的时候，如果不加limit，执行的时候一个**「不小心手抖」**，可能数据全删掉了，如果**「删错」**了呢？加了limit 200，就不一样了。删错也只是丢失200条数据，可以通过binlog日志快速恢复的。
     - **「SQL效率很可能更高」**，你在SQL行中，加了limit 1，如果第一条就命中目标return， 没有limit的话，还会继续执行扫描表。
     - **「避免了长事务」**，delete执行时,如果age加了索引，MySQL会将所有相关的行加写锁和间隙锁，所有执行相关行会被锁住，如果删除数量大，会直接影响相关业务无法使用。
     - **「数据量大的话，容易把CPU打满」** ,如果你删除数据量很大时，不加 limit限制一下记录数，容易把cpu打满，导致越删越慢的。

   - 变更SQL操作先在测试环境执行，写明详细的操作步骤以及回滚方案，并在上生产前review。

   - 小表驱动大表是，即小的数据集驱动大的数据集：

     - 当B表的数据集比A表小时，用in优化 exist两表执行顺序是先查B表再查A表查询语句：SELECT * FROM A WHERE id in (SELECT id FROM B) ;
     - 当A表的数据集比B表小时，用exist优化in ，两表执行顺序是先查A表，再查B表，查询语句：SELECT * FROM A WHERE EXISTS (SELECT id FROM B WHERE A.id = B.ID) ;
     - 尽量使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表

   -  写完SQL语句，检查where,order by,group by后面的列，多表关联的列是否已加索引，优先考虑组合索引。

     - 反例

       ![img](https://pic1.zhimg.com/80/v2-2c17bb24ec3277f2d99ae1bacb78d8e4_720w.webp)

     - 正例

       > ```添加索引
       > 添加索引
       > alter table user add index idx_address_age (address,age)
       > ```

       ![img](https://pic4.zhimg.com/80/v2-16ec32fe1b4090bf69aad00deb0486bf_720w.webp)

   - 修改或删除重要数据前，要先备份，先备份，先备份

   - where后面的字段，留意其数据类型的隐式转换

     `字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较，最后导致索引失效`

   - 尽量使用varchar代替 char

     - 因为首先变长字段存储空间小，可以节省存储空间
     - 其次对于查询来说，在一个相对较小的字段内搜索，效率更高

   - SQL修改数据，养成begin + commit 事务的习惯

   - WHERE从句中不对列进行函数转换和表达式计算

2. SQL的一些优雅习惯

   1. 设计表的时候，所有表和字段都添加相应的注释（SQL规范优雅）

      `这个好习惯一定要养成啦，设计数据库表的时候，所有表和字段都添加相应的注释，后面更容易维护。`

   2. SQL书写格式，关键字大小保持一致，使用缩进。

   3. INSERT语句标明对应的字段名称

   4. 设计数据库表的时候，加上三个字段：主键，create_time,update_time。

   5. 所有表必须使用Innodb存储引擎

   6. 数据库和表的字符集统一使用UTF8

   7. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释

   8. 索引命名要规范

      1. 主键索引名为 pk_ 字段名；
      2. 唯一索引名为 uk _字段名 ；
      3. 普通索引名则为 idx _字段名;
      4. 但是需要注意，索引名称长度限制64，单个表最大索引数16，超过的话就创建失败。

3. 优化索引的使用

   - 尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。
   - 不做列运算，把计算都放入各个业务系统实现
   - 查询语句尽可能简单，大语句拆小语句，减少锁时间
   - or 查询改写成 union 查询
   - 不用函数和触发器
   - 避免 %xx 查询，可以使用：select * from t where reverse(f) like reverse(’%abc’);
   - 少用 join 查询
   - 使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123
   - 尽量避免在 where 子句中使用 != 或者 <> 操作符，查询引用会放弃索引而进行全表扫描
   - 列表数据使用分页查询，每页数据量不要太大
   - 避免在索引列上使用 is null 和 is not null

4. 表结构设计优化

   - 使用可以存下数据最小的数据类型。
   - 尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。
   - 尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。数字可以默认 0 ，字符串默认 “”
   - 尽量少用 text 类型，非用不可时最好独立出一张表。
   - 尽量使用 timestamp，而非 datetime。
   - 单表不要有太多字段，建议在 20 个字段以内。

5. 如果以上优化还有问题，可以使用 show profiles 分析 sql

   1. show profiles

   2. show profile for query [queryId]

      ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mODlkZDliMy1hZmY2LTRjYjgtYjUyMy03ZjU2NDM2ZGYzZTcucG5n?x-oss-process=image/format,png)

      - show profile 返回结果字段含义

        1. Status ： sql 语句执行的状态

           status出现以下情况的建议

           - System lock

             > 确认是由于哪个锁引起的，通常是因为MySQL或InnoDB内核级的锁引起的。`建议`：如果耗时较大再关注即可，一般情况下都还好

           - Sending data

             > 解释：从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见。
             > 备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net。建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量

           - Sorting result

             > 正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序。
             > `建议`：创建适当的索引

           - Table lock

             > 表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表

           - create sort index

             > 当前的SELECT中需要用到临时表在进行ORDER BY排序
             > `建议`：创建适当的索引

           - createing tmp table

             > 创建临时表。先拷贝数据到临时表，用完后再删除临时表。消耗内存，数据来回拷贝删除，消耗时间，`建议`：优化索引

           - converting HEAP to MyISAM

             > 查询结果太大，内存不够，数据往磁盘上搬了。`建议`：优化索引，可以调整max_heap_table_size

           - Copying to tmp table on disk

             > 把内存中临时表复制到磁盘上，危险！！！`建议`：优化索引，可以调整tmp_table_size参数，增大内存临时表大小

        2. Duration: sql 执行过程中每一个步骤的耗时

        3. CPU_user: 当前用户占有的 cpu

        4. CPU_system: 系统占有的 cpu

        5. Block_ops_in : I/O 输入

        6. Block_ops_out : I/O 输出

      - show profile type 选项

        1. all：显示所有的性能开销信息
           block io：显示块 IO 相关的开销信息
           context switches: 上下文切换相关开销
           cpu：显示 CPU 相关的信息
           ipc：显示发送和接收相关的开销信息
           memory：显示内存相关的开销信息
           page faults：显示页面错误相关开销信息
           source：显示和 Source_function、Source_file、Source_line 相关的开销信息
           swaps：显示交换次数的相关信息

## 三范式

第一范式：每个表的每一列都要保持它的原子性，也就是表的每一列是不可分割的；

第二范式：在满足第一范式的基础上，每个表都要保持唯一性，也就是表的非主键字段完全依赖于主键字段；

第三范式：在满足第一范式和第二范式的基础上，表中不能产生传递关系，要消除表中的冗余性；

### 范式的优缺点

1. 优点
   - 范式化的更新操作通常比反范式化要快；
   - 当数据较好地范式化后，就只有很少或者没有重复数据，所以只需要修改更少的数据；
   - 范式化的表通常更小，可以更好地存放在内存中，执行操作更快；
   - 很少有冗余的数据，意味着检索数据时更少使用distinct或group by语句；
2. 缺点
   - 查询时，由于分表的原因，常常需要表关联；
   - 可能无法触发索引；

### 反范式的优缺点

1. 优点
   - 由于都在一个表里，可以减少表关联查询；
   - 可能同属于一个索引的字段，不用分表，触发索引更方便；
2. 缺点
   - 存储过多的冗余数据
   - 查询时可能需要distinct或group by的情况更多；
   - 在实际的开发中，都是混用范式化和反范式化，有的时候必要的冗余，有益而无害。

## 事务的四个特性

1. **原子性**：一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性

2. **一致性**：事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

   如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态

3. **隔离性**：

   事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。

   在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化

   1. 读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取

   2. 授权读取也称为已提交读（Read Commited），授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。

   3. 可重复读（Repeatable Read)

      就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；

   4. 串行化

      是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。

4. **持久性**：

   一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态

## MYSQL explain 详解

explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。
1. id SELECT识别符。这是SELECT查询序列号。

2. select_type 有以下几种值
    - simple 它表示简单的select,没有union和子查询
    - primary 最外面的select,在有子查询的语句中，最外面的select查询就是primary
    - union union语句的第二个或者说是后面那一个.
        `explain select  *  from uchome_space limit 10 union select * from uchome_space limit 10,10`
    - dependent union  UNION中的第二个或后面的SELECT语句，取决于外面的查询
    - union result  UNION的结果
    
3. table 输出的行所用的表，这个参数显而易见，容易理解

4. type 连接类型。有多个参数，先从最佳类型到最差类型介绍**重要且困难**
    - system 表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计
    - const 表最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快记住一定是用到primary key 或者unique，并且只检索出两条数据的 情况下才会是const,看下面这条语句
    - eq_ref 对于eq_ref的解释，mysql手册是这样说的:"对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY"。看下面的语句
    `explain select * from uchome_spacefield,uchome_space where uchome_spacefield.uid = uchome_space.uid`
    - ref 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。
    - ref_of_null 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。
    - index_merge 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。
    - unique_subquery
    - index_subquery
    - range 给定范围内的检索，使用一个索引来检查行。看下面两条语句
    `explain select * from uchome_space where uid in (1,2)`
    `xplain select * from uchome_space where groupid in (1,2)`
    uid有索引，groupid没有索引，结果是第一条语句的联接类型是range,第二个是ALL.以为是一定范围所以说像 between也可以这种联接,很明显
    - index 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
    - ALL 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记 const的表，这通常不好，并且通常在它情况下 很差。通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。
    
5. possible_keys 提示使用哪个索引会在该表中找到行，不太重要

6. keys MYSQL使用的索引，简单且重要

7. key_len MYSQL使用的索引长度

8. ref ref列显示使用哪个列或常数与key一起从表中选择行。

9. rows 显示MYSQL执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引

10. Extra 该列包含MySQL解决查询的详细信息。
    - Distinct MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。一直没见过这个值
    - Not exists
    - range checked for each record 没有找到合适的索引
    - using filesort 
    - using index 只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的信息。这个比较容易理解，就是说明是否使用了索引
    - using temporary 为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。
    - using where WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。（这个说明不是很理解，因为很多很多语句都会有where条件，而type为all或index只能说明检索的数据多，并不能说明错误，useing where不是很重要，但是很常见）
    - using sort_union(...), using union(...), using intersect(...) 这些函数说明如何为index_merge联接类型合并索引扫描
    - using index for group-by 类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。
    
11. 为什么不建议使用外键
    
    > 在早期的数据库表结构设计中，往往会把一张表引用另外一张表的字段（通常是 id）作为外键，借助 MySQL 自动维护外键，确实能够省掉很多开发工作，但是外键实际的代价不低，很多数据表设计规范已经明确禁止使用外键。
    
    外键并不是没有代价的。事实上，外键通常会需要服务器地在更改数据的时候检查另一张表。尽管 InnoDB 使用了索引提高这个操作速度，但并没有让数据检查的影响消失。甚至还可能产生一个很大的没有筛选性的索引。
    当然，外键在某些情况也能够改善性能。如果我们需要保证两个关联表的数据必须保持一致的时候，使用 MySQL 服务器进行检测会比程序来检测效率更高。外键在那种`级联删除`或更新的场合也很有用。但是这类操作是逐行进行的，因此会比批量删除或批量操作更慢。
    
    > 从众多互联网企业的数据库设计规范来看，外键是一再被重申要被禁用的。不单单是性能问题，而且互联网的业务多变，如果是表结构发生变动，很可能会导致外键关联的表出现意想不到的问题。因此，在非必要的情况下不要用外键，除非你只是为了验证外键的功能。

## MYSQL索引合并

MySQL在一般情况下执行一个查询时最多只会用到单个二级索引，但存在有特殊情况，也可能在一个查询中使用到多个二级索引，MySQL中这种使用到多个索引来完成一次查询的执行方法称之为：**索引合并/index merge**

### 一、intersection合并

Intersection是交集的意思。某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比如下面的例子：

```mysql
	SELECT * FROM employees WHERE name = 'lizhi' AND hire_time = '2022-03-30 23:00:00';
```

如果这个查询使用Intersection合并的方式执行的话，大概步骤如下：

1. 从`idx_name`二级索引对应的B+树中取出`name = 'lizhi'`的所有记录

2. 再从`idx_hire_time`二级索引对应的B+树中取出`hire_time='2022-03-30 23:00:00'`的所有记录。

3. 因为二级索引的叶子节点都是由索引列和主键ID构成的，可以计算出两个二级索引结果集中主键ID的交集

4. 据交集中的主键ID进行回表操作

   **注：至于为什么不直接使用其中一个索引，根据查询条件过滤出主键ID，然后回表再判断其他的查询条件是否满足，主要因为回表操作是一个随机I/O操作，性能比较差。如果可以通过二级索引的的顺序IO进行条件过滤，然后只对交集中的主键进行回表操作，可以大大减少随机I/O读取的成本消耗。**

- **等值匹配**

  二级索引列是等值匹配的情况才有可能使用到索引合并，而对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。

- **主键范围匹配**

  二级索引列都是等值匹配的情况下才可能使用Intersection索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。

  Intersection索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很容易。

  但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。

  按照有序的主键值去回表取记录有个专有名词，叫：**Rowid Ordered Retrieval，简称ROR**。

### 二、Union合并

在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。有时候OR关系的不同搜索条件会使用到不同的索引，比如下面的例子：

```mysql
SELECT * FROM employees WHERE name = 'lizhi' OR hire_time = '2022-03-30 23:00:00';
```

Union是并集的意思，适用于使用不同索引的搜索条件之间使用OR连接起来的情况。

与Intersection索引合并类似，MySQL在某些特定的情况下才可能会使用到Union索引合并。

其中等值匹配和主键范围匹配与Intersection合并中的是一样，只是Unon合并多了一种情况。

1. **使用Intersection索引合并的搜索条件**

   搜索条件的某些部分使用Intersection索引合并的方式得到的主键集合和其他方式得到的主键集合取并集，比方说这个查询：

   ```mysql
   SELECT * FROM employees WHERE age = 22 AND position = 'dev' OR (name = 'lizhi' AND hire_time = '2022-03-30 23:00:00');
   ```

   先按照搜索条件name = 'lizhi' AND hire_time = '2022-03-30 23:00:00'从索引idx_name和idx_hire_time中使用Intersection索引合并的方式得到一个主键集合。

   再按照搜索条件 age = 22 AND position = 'dev'从联合索引idx_age_position中得到另一个主键集合。

   采用Union索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回。

### 三、Sort-Union合并

Union索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到Union索引合并：

```mysql
SELECT * FROM employees WHERE name > 'lizhi' OR hire_time < '2022-03-30 23:00:00';
```

这是因为根据这两个条件分别从idx_name和idx_hire_time二级索引中取出来的主键并不一定是有序的。

但MySQL可以对这两个索引满足条件的主键集合进行排序，然后在进行Union。

上述这种先按照二级索引记录的主键值进行排序，之后按照Union索引合并方式执行的方式称之为Sort-Union索引合并，很显然，这种Sort-Union索引合并比单纯的Union索引合并多了一步对二级索引记录的主键值排序的过程。

### 四、如何选择合适的索引列顺序

![img](https://box.kancloud.cn/22f3a91db8177e6ccdeacaa0c77410b0_564x240.png)

### 五、聚簇索引

聚簇索引是一种数据的存储方式，**它的数据行只存放在索引（B+树）的叶子中，内部节点不存放数据**。

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引

1. 优势

   - 由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
   - 聚簇索引适合用在排序的场合，非聚簇索引不适合
   - 取出一定范围数据的时候，使用用聚簇索引速度快
   - 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

2. 劣势

   - 如果使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，

   - 所以建议使用int的auto_increment作为主键

     - **为什么主键通常建议使用自增id**

       - 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

       - 因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取。聚簇索引则只需一次I/O。（强烈的对比）

         **不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。**

   - 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间

### 六、非聚簇索引

非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。

1. 聚簇索引与非聚簇索引对比

   ![img](https://upload-images.jianshu.io/upload_images/15388344-c3d33e4688625c9b.png?imageMogr2/auto-orient/strip|imageView2/2/w/649/format/webp)

   非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。

### 七、覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”
我们知道 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。**覆盖索引**就是把要查询出的**列和索引是对应**的，不做**回表**操作

第一个SQL语句

```mysql
SELECT id, name FROM user WHERE name='shenjian';
```

能够命中 name 索引，索引叶子节点存储了主键 id，通过 name 的索引树即可获取 id 和 name，无需回表，符合索引覆盖，效率较高。

第二个SQL语句

```mysql
SELECT id, name, sex FROM user WHERE name='shenjian';
```

能够命中 name 索引，索引叶子节点存储了主键 id，但 sex 字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过 id 值扫码聚集索引获取 sex 字段，效率会降低。

`如果把 (name) 单列索引升级为联合索引 (name, sex) 就不同了`：
再次执行，第二个SQL语句：

能够命中 联合索引，索引叶子节点存储了主键 id，通过 联合索引 的索引树即可获取 name 和 sex，无需回表，符合索引覆盖，效率较高。

### 八、冗余和重复索引

1. 重复索引

   > ALTER TABLE a ADD INDEX ‘idx_1’ (‘id’,’name’,’sex’)
   > ALTER TABLE a ADD INDEX ‘idx_2’ (‘id’,’name’,’sex’)
   > ALTER TABLE a ADD INDEX ‘idx_3’ (‘id’,’name’,’sex’)

   指的是在对应列上，以相同的顺序不同的索引名称建立了多套一模一样的联合索引

   这三个就是重复索引，占用三倍的索引磁盘存储空间，降低了SQL查询优化器判断选择的性能。非常不可取！

2. 冗余索引

   > ALTER TABLE a ADD INDEX ‘idx_1’ (‘id’,’name’,’sex’)
   > ALTER TABLE a ADD INDEX ‘idx_2’ (‘id’,’name’,’phone’)
   > ALTER TABLE a ADD INDEX ‘idx_3’ (‘id’,’name’,’address’)
   > ALTER TABLE a ADD INDEX ‘idx_4’ (‘id’,’name’)

   指的是不同的联合索引组合，某一列或者几列字段被多组索引覆盖，一般称这些列存在冗余索引

   这种创建方式，套在id,name两个列上的索引会有4个，我们知道索引的前置匹配规则，id,name套了四层，树结构也会冗余四层，这是非常浪费空间的，同时在查询的时候，由于id和name有四种索引可以选择，SQL优化器的性能也会受影响，这种方式虽然很多时间没办法避免，但是可以尽量优化。

   1. 为什么无法避免？

      业务SQL就是需要id,name,address一种查询条件组合，id,name,phone又一种查询组合，而address和phone唯一性比较高，不加联合索引会导致大量的扫表和回表查询，拖慢查询性能。

   2. 如何优化？

      sex这种要么男要么女的列，就不要增加一个联合索引了，因为它的区分度不高，假设有100万人，五十万女人，那么sex通过辅助索引查50万id再做回表主键索引查，这样该扫的行还是很多，加了索引基本没什么用，复用id,name的组合方式就可以。
      像已经有那么多id,name，XXX的组合了，单独id,name这个顺序组合的索引就可以不要了，让优化器自动匹配其它的联合索引，它们根据左匹配，肯定会顺着查id,name的。

## 为什么查询速度会慢

### 一、MySQL查询的执行过程

1. MySQL在查询时，它是由很多子任务组成的，每个子任务都会消耗一定的时间，如果要想优化查询，实际上要优化其子任务，可以消除一些子任务、减少子任务的执行次数、让子任务执行的更快。
2. MySQL查询的执行过程：从客户端到服务器、然后在服务器进行解析、生成执行计划、执行、返回结果给客户端。
3. 执行是最重要的阶段，包括调用存储引擎检索数据、调用后的数据处理、排序、分组等；
4. 查询需要在不同的地方花费时间，包括网络、CPU计算、生成统计信息、生成执行计划、锁等待等，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的IO操作上花费时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。
5. 不必要的额外操作、不必要的重复操作、某些操作执行的太慢都是查询慢的原因，优化查询的目的就是减少和消除这些操作所花费的时间。

### 二、是否查询了不需要的数据

有些查询会查询很多不需要的数据，查询之后，程序中并未使用，这样不但会给MySQL服务器带来额外的负担，还会增加网络开销，也会消耗应用服务器的CPU和内存资源，简而言之，吃多少拿多少。

千万不要有`“把数据都查出来，用Java代码过滤”`的想法。

禁止使用`select *`进行查询。

### 三、衡量查询开销的几个重要指标

1. **响应时间**

   响应时间可以分为服务时间和排序时间。

   - 服务时间指数据库处理这个查询真正花费的时间；
   - 排队时间指服务器因为等待某些资源而没有真正执行查询的时间，比如等待IO操作、等待行锁。

2. **扫描的行数和返回的行数**

   较短的行的访问速度更快，内存中的行比磁盘中的行的访问速度要快得多。

   理想情况下扫描的行数和返回的行数是相同的。但这种情况并不多见，比如关联查询的时候，服务器必须扫描更多的行才能得到结果，因此，越多的表关联，性能越低。

3. **扫描的行数和访问类型**

   MySQL可以通过多种方式查询并返回结果集，速度从慢到快，扫描的行数由多到少，依次为全表扫描、索引扫描、范围扫描、唯一索引扫描、常数引用。

   最常用的优化方式是为查询增加一个合适的索引，索引可以让MySQL以最高效、扫描行数最少的方式找到需要的记录。

## 缓存表和汇总表

有时提升性能最好的方法是在同一张表中保存衍生的冗余数据，有时候还需要创建一张完全独立的汇总表或缓存表。

缓存表用来存储那些获取很简单，但速度较慢的数据；

汇总表用来保存使用group by语句聚合查询的数据；

对于缓存表，如果主表使用InnoDB，用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文检索。

在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。哪个更好依赖于应用程序，但是定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引。

当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用，这就需要通过使用影子表来实现，影子表指的是一张在真实表背后创建的表，当完成了建表操作后，可以通过一个原子的重命名操作切换影子表和原表。

为了提升读的速度，经常建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表，这些方法会增加写的负担妈也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧，虽然写操作变慢了，但更显著地提高了读的性能。

## 视图与物化视图

1. 视图

   视图可以理解为一张表或多张表的与计算，它可以将所需要查询的结果封装成一张虚拟表，基于它创建时指定的查询语句返回的结果集。

   查询者并不知道使用了哪些表、哪些字段，只是将预编译好的SQL执行，返回结果集。每次查询视图都需要执行查询语句。

2. 物化视图

   为了防止每次都查询，先将结果集存储起来，这种有真实数据的视图，称为物化视图。

   MySQL并不原生支持物化视图，可以使用Justin Swanhart的开源工具Flexviews实现。

   相对于传统的临时表和汇总表，Flexviews可以通过提取对源表的更改，增量地重新计算物化视图的内容。

## 加快alter table操作的速度

MySQL的alter table 操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构的操作的方法使用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。

这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下更为严重。

改善的方法有两种：

1. 是先在一台不提供服务的机器上执行alter table操作，然后和提供服务的主表进行切换；
2. 方式是通过影子拷贝，影子拷贝的技巧是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表的操作交换两张表。

## 计数器表

1. 常用在网站的统计功能上面

2. 可以单独设置一个计数表，然后对于每一次动作触发都有更新一下计数器表

3. 例如一个网站点击量计数器表，内容是

   ```mysql
   	create table hit_counter(
   		cnt int unsigned not null
   	)engine=InnoDB
   ```

4. 对于计数器表，有一个问题，就是多个触发只能串行执行，因为只有一条记录，所以一种思路是先插入多个记录，比如100条记录，然后每次随机选个记录更新，最后再用sum计算总和就可以了，这样就可以进行行内并发了，语句如下

   ```mysql
   	create table hit_counter(
   		slot tinyint unsigned not null primary key,
   		cnt int unsigned not null
   	)engine=InnoDB
   ```

5. 当然，一般我们常用隔天计数，这时候为了实现这种机制，我们可以加入一个day属性，用来记录插入记录的日期。上面说了，我们需要主动插入一个100个值，从而实现并发。在mysql中，有一种语句叫做`on duplicate key`,就是在插入的时候，如果在插入位置已经有了一项记录之后，就会自动变为更新语句。所以，insert语句可以变为

   ```mysql
   	insert into daily_hit_counter (day,slot,cnt) values (CURRENT_DATE,RAND()*100,1)
   	ON DUPLICATE KEY UPDATE cnt=cnt+1;
   ```

## MySQL查询执行过程

查询的生命周期大致可以按照顺序来看：从客户端到服务端，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中 “执行” 可以认为是整个生命周期中最重要的阶段，其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序分组等。当希望 MySQL 能够以高性能的方式运行查询时，最好的办法就是弄清楚 MySQL 是如何优化和执行查询的。MySQL 执行一个查询的过程，如下：
![img](https://img-blog.csdnimg.cn/20191204202628302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=,size_16,color_FFFFFF,t_70)

1. 首先我们会连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。然后客户端发送一条查询给服务器；【1】首先我们会连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。然后客户端发送一条查询给服务器；

   > 开始执行这条sql时，首先会校验你的用户名和密码是否正确，若是不正确会返回错误信息："Access denied for user"；

2. 服务器先检查查询**缓存**，如果命中缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；

   > 注意：Mysql中的缓存比较适合于那些静态的表，更新不频繁的表，因为只要当前表有数据更新，关于该表的缓存就会失效，若是表更新频繁缓存频繁的失效，这样维护缓存的消耗的性能远大于使用缓存带来的性能优化，这样就会得不偿失，严重影响 Mysql的性能，所以在 Mysql 8版本中的时候把缓存这一块给砍掉了。个人感觉，没必要砍掉，可以设置成默认关闭缓存，需要的时候再设置开启，并且可以通过配置参数指定特定的表使用缓存，那些表不使用缓存，这样或许使用缓存更有效。

3. 服务器进行**SQL解析**、预处理、再由优化器生成对应的执行计划（这个过程中任何语法等错误都可能终止查询）。分析器主要有两步：（1）词法分析（2）语法分析；

   > 语法解析器和预处理：MySQL 通过关键字将 SQL 语句进行解析，并生成一颗对应的 “解析树”。MySQL 解析器使用 MySQL 语法规则验证和解析查询。例如验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，还会验证引号前后是否正确等。预处理器则根据一些 MySQL 规则进一步检查解析树是否合法（数据或数据列是否存在等）。预处理器会验证权限，通常很快。

4. MySQL 根据**优化器**生成的执行计划，调用存储引擎的 API 来执行查询。优化器是在表里面有多个索引的时候，决定使用哪个索引。或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序；

   > 优化器：将语法树转化成执行计划。一条查询可以有多种执行方式，最终都返回相同的结果。优化器的作用就是找到其中最好的执行计划。MySQL 基于成本的优化器，它尝试预测一个查询使用某种执行计划的成本，并选择成本最小的一个。可以通过 SHOW STATUS LIKE 'Last_query_cost' 值得知 MySQL 计算的当前查询的成本。

5. MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了**执行器阶段**，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，将结果返回给客户端，也会将结果存放到查询缓存中；

### 一、MySQL 客户端/服务器通信协议

1. MySQL 客户端和服务端之间的通信协议是 “半双工”的，意味着，在任何一个时刻，要么是服务器向客户端发送数据，要么是由客户端向服务端发送数据，这两个动作不能同时发生。我们无法也无需将一个消息切成小块独立来发送。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。
2. 客户端用一个单独的数据包将查询传给服务器，这也是为什么查询的语句很长的时候，参数 max_allowed_packet 就特别重要了。一旦客户端发送了请求，它能做的事情就只能等待结果了。相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。
3. 当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。

### 二、查询缓存

在分析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。当命中缓存之后，MySQL 会检查一次用户权限。如果权限没问题，MySQL 会跳过所有其他阶段，直接从缓存中拿到结果并返回。

### 三、语法分析器和预处理

MySQL 通过关键字将 SQL 语句进行解析，并生成一棵对应的 “解析树”。MySQL 解析器将使用 MySQL 语法规则校验和解析查询。例如，它验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。预处理则根据一些 MySQL 规则进一步检查解析树是否合法，例如，这里检查数据表和数据列是否存在，还会解析名字和别名，看看他们是否有歧义。下一步预编译器会验证权限。这通常很快，除非服务器上有非常多的权限配置。

### 四、查询优化器

当语法树被认为合法时，优化器会将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同结果。优化器的作用就是找到这其中最好的执行计划。MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。可以通过查询当前会话的 Last_query_cost 的值来得知 MySQL 计算的当前查询的成本。

```mysql
SHOW STATUS LIKE 'Last_query_cost'
+-----------------+------------+
|  Variable_name  | Value      |
+-----------------+------------+
| Last_query_cost | 1030.47800 |
+-----------------+------------+
```

上述结果表示 MySQL 的优化器认为大概需要 1030个数据页的随机查找才能完成上述的查询。很多原因会导致 MySQL 优化器选择错误的执行计划，如下：

- **统计信息不准确：**MySQL 依赖存储引擎提供的统计信息来评估成本，但有的偏差可能非常大。例如，InnoDB 因为其 MVCC 的架构，并不能维护一个数据表的行数的精确统计信息。
- 执行计划中的成本估算不等同实际执行的成本：所以即使统计信息精准，优化器给出的执行计划也可能不是最优的。例如某个执行计划虽然需要读取更多的页面，但是它的成本却更小。因为如果这些页面都是顺序读或者页面都已经在内存中的话，那么它的访问成本将很小。MySQL 层面并不知道哪些页面在内存中、哪些在磁盘上，所以查询实际执行过程中到底需要多少次物理 I/O 是无法得知的。
- **MySQL 的最优可能和我们想的最优不一样：**我们希望执行时间尽可能短，但是MySQL 只是基于其成本模型选择最优的执行计划，有时候并不是最快的执行方式。所以，我们根据执行成本选择执行计划并不是完美的模型。
- **MySQL 从不考虑其他并发执行的查询：**可能会影响到当前查询的速度。
- **MySQL 也并不是任何时候都是基于成本的优化：**有时也基于一些固定的规则。
- **MySQL 不会考虑不受其控制的操作的成本：**例如执行存储过程或者用户自定义函数的成本。
- 优化器有时候无法估算所有可能的执行计划，所以它可能错过实际上最优的执行计划。
  MySQL 的查询优化器使用了很多优化策略来生成一个最优的执行计划。优化侧率可以简单分为两种：静态优化和动态优化。静态优化可以直接对解析树进行分析，并完成优化。动态优化则和查询的上下文有关，也可能和很多其它因素有关，例如WHERE 条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候都重新评估，可以认为这是 “运行时优化”。下面是一些 MySQL 能够处理的优化类型：
  1. **重新定义关联表的顺序：**数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分功能。
  2. **使用等价变换规则：**MySQL 可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。例如：（5=5 AND a>5）将被改写为 a>5；
  3. **将外连接转化成内连接：**并不是所有的 OUTER JOIN 语句都必须以外连接的方式执行。
  4. **优化 COUNT()、MIN() 和 MAX()：**要找到某一列的最小值，只需要查询对应 B-Tree 索引最左端的记录，MySQL 可以直接获取索引的第一行记录。在优化器生成执行计划的时候就可以利用这一点，在 B-Tree 索引中，优化器会将这个表达式作为一个常数对待。
  5. **预估并转化为常数表达式：**当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。
  6. **覆盖索引扫描：**当索引中的列包含所有查询的列时，MySQL 就可以使用索引返回需要的数据，而无须查询对应的数据行。
  7. **子查询优化：**MySQL 在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。
  8. **提前终止查询：**如果发现已经满足查询需求，MySQL 总是能够立刻终止查询。典型的例子就是 LIMIT 子句。
  9. 列表IN() 的比较：很多数据库系统中，IN()完全等同于多个 OR 条件子句，因为这两个是完全等价的。在MySQL中不成立，IN()列表中的数据先排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个 O(logn)复杂度的操作，等价地转化成 OR 查询的复杂度为 O(n)，对于 IN() 列表有大量取值的时候，MySQL 的处理速度将会更快。

### 五、执行计划

和很多其他关系数据库不同，MySQL 并不会生成查询字节码来执行查询。MySQL 生成查询的一颗指令树，然后通过存储引擎执行完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行 EXPLAIN EXTENDED 后，再执行 SHOW WARNINGS，就可以看到重构出的查询。MySQL 总是从一个表开始一直嵌套循环、回溯完成所有表关联。所以，MySQL 的执行计划总是如下图所示：是一颗左侧深度优先的树。

> explain 的 extended 扩展能够在原本 explain的基础上额外的提供一些查询优化的信息，这些信息可以通过 mysql 的 show warnings 命令得到。

![img](https://img-blog.csdnimg.cn/20200210160434469.png)

### 六、查询执行引擎

在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是字节码。MySQL 根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是我们称为 “handler API” 的接口。查询中的每一个表由一个 handler 的实例表示。实际上，MySQL 在优化阶段就为每个表创建了 handler 实例，优化器根据这些实例的接口可以获取表的相关信息，包括标的所有列名，索引统计信息等等。

### 七、返回结果给客户端

最后一个阶段是将结果返回给客户端，即使查询不需要返回结果集给客户端，MySQL 仍然会返回这个查询的一些信息，如该查询影响到的行数。如果查询可以被缓存，那么 MySQL 在这个阶段也会将结果存放到查询缓存中。MySQL 将结果集返回客户端是一个增量、逐步返回的过程。例如：关联查询操作，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL 就可以开始向客户端逐步返回结果集了。这样处理的好处：服务端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。另外，这样处理也让 MySQL客户端第一时间获得返回的结果。
结果集中的每一行都会以一个满足 MySQL 客户端/服务端通信协议的封包发送，再通过 TCP 协议进行传输，在 TCP 传输的过程中，可能对 MySQL 的封包进行缓存然后批量传输。