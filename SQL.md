# 数据库

## 一、mysql 索引详解

1. 什么是索引

   > 官方介绍索引是帮助MySQL**高效获取数据**的**数据结构**。简单来讲，[数据库索引](https://so.csdn.net/so/search?q=数据库索引&spm=1001.2101.3001.7020)就像是书前面的目录，能**加快数据库的查询速度**。
   >
   > 事实上，索引是一种数据结构，用于帮助我们在**大量数据**中快速定位到我们想要查找的数据。

   但对于海量数据来说，它的目录也是很大的，不可能全部存储在内存中，因此**索引往往是存储在磁盘上的文件中**（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。

2. 索引的分类

   1. 单列索引

      一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了

      - 普通索引：MySQL中基本[索引类型](https://so.csdn.net/so/search?q=索引类型&spm=1001.2101.3001.7020)，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。
      - [唯一索引](https://so.csdn.net/so/search?q=唯一索引&spm=1001.2101.3001.7020)：索引列中的值必须是唯一的，但是允许为空值。
      - 主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。

   2. 组合索引

      在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

   3. 全文索引

      全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。

3. 索引的数据结构

   索引的数据结构使用的是B+树，那为什么使用B+树而不是二叉查找树、平衡二叉树或者B树呢，接下来，我们来讲讲B+树的由来。

   ##### 二叉查找树

   它的特点：

   > 1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
   > 2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   > 3. 它的左、右子树也分别为二叉查找树。

   二叉查找树的特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这是我们不想见到的。

   ##### 二叉平衡树

   平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

   使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。

   就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：

   > 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s）
   >
   > 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。

   ##### B树：改造二叉平衡

   对于二叉平衡树，我们更希望出现‘矮胖’树而不是‘瘦高’树，因为这样可以减少查询时的IO操作次数，增加查询效率。那么我们如何能够降低树的高度呢？

   假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）

   因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。

   ![img](https://img-blog.csdnimg.cn/1edcf35f41bd4baf8f8b3a29eab6d548.png)

   这种数据结构我们称为B树，B树是一种多叉平衡查找树，主要特点如下：

   > 1. B树的节点中存储着多个元素，每个内节点有多个分叉。
   > 2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
   > 3. 父节点当中的元素不会出现在子节点中。
   > 4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

   到这里，B树已经是比较理想的了，但我们还有可以优化的地方：

   > B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
   >
   > 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

   ##### B+树：改造B树

   B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于**非叶子节点是否存储数据**的问题

   > - B树：非叶子节点和叶子节点都会存储数据。
   > - B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

   ![img](https://img-blog.csdnimg.cn/8a0e2789eb3b491286cdd287fc89fe23.png)

   B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟这增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。

4. MySQL索引的优化

   - 避免回表

     在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？

     使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）

     如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。

     **这就是一个典型的使用覆盖索引的优化策略减少回表的情况。**

   - 联合索引的使用

     联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。

     联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那建议这种情况下使用联合索引。

     **联合索引的使用：**

     > 1. 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
     > 2. 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。

