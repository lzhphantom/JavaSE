# 数据库

## 一、mysql 索引详解

1. 什么是索引

   > 官方介绍索引是帮助MySQL**高效获取数据**的**数据结构**。简单来讲，数据库索引就像是书前面的目录，能**加快数据库的查询速度**。
   >
   > 事实上，索引是一种数据结构，用于帮助我们在**大量数据**中快速定位到我们想要查找的数据。

   但对于海量数据来说，它的目录也是很大的，不可能全部存储在内存中，因此**索引往往是存储在磁盘上的文件中**（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。
   ### 索引的优缺点
   1. 优点：
   - 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
   - 索引可以帮助服务器避免排序和创建临时表
   - 索引可以将随机IO变成顺序IO
   - 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性
   - 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
   - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   - 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
   - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
   - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
   2. 缺点：
     - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
     - 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
     - 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
     - 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
     - 对于非常小的表，大部分情况下简单的全表扫描更高效；

2. 索引的分类

   1. 单列索引

      一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了

      - 普通索引：MySQL中基本<font color=red>索引类型</font>，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。
      - <font color=grayblue>唯一索引</font>：索引列中的值必须是唯一的，但是允许为空值。
      - 主键索引：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。

   2. 组合索引

      在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

   3. 全文索引

      全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。
   4. 前缀索引

      所谓前缀索引：<font color=red>`说白了就是对文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快。`</font>这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数
      那么为什么不对整个字段建立索引呢？一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，<font color=red>`前缀索引仅仅是选择一个字段的部分字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性`</font>
      *什么是索引选择性*
      关于索引的选择性，它是指不重复的索引值和数据表的记录总数的比值，取值范围在 [0,1] 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行
      那是不是选择性越高的索引越好呢？当然不是！索引选择性最高为 1，如果索引选择性为 1，就是唯一索引了，搜索的时候就能直接通过搜索条件定位到具体一行记录！这个时候虽然性能最好，但是也是最费空间的，这不符合我们创建前缀索引的初衷
      我们一开始之所以要创建前缀索引而不是唯一索引，`就是希望能够在索引的性能和空间之间找到一个平衡，`我们希望能够选择足够长的前缀以保证较高的选择性（这样在查询的过程中就不需要扫描很多行），但是又希望索引不要太过于占用存储空间
      那么我们该如何选择一个合适的索引选择性呢？`索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数`

        - 首先可过如下 SQL 得到全列选择性
          
            > SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
        - 然后再通过如下 SQL 得到某一长度 prefix_length
            > SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
      > 在上面这条 SQL 执行的时候，我们要注意选择合适的 prefix_length，直至计算结果`最接近于`全列选择性的时候，就是最佳结果了，然后使用这个 prefix_length 就可以创建前缀索引了
      > 在前缀索引中 B+Tree 里保存的`根本就不是完整的`表字段的值，必须要回表才能拿到需要的数据。所以，用了前缀索引，就用不了覆盖索引了
      > *创建前缀索引*
            >
            > alter table city_demo add index city_index(city(14));
            
            1. 前缀索引是一种能使索引占用空间更小，查询速度更快的有效办法，但另一方面也有其缺点：mysql 无法使用其前缀索引做 `ORDER BY` 和 `GROUP BY`，用了前缀索引，就用不了覆盖索引了
            2. 要明确使用前缀索引的目的与优势

        - 大大节约索引的占用空间，从而提高索引效率
        - 对于 `BOLB 、TEXT `或者很长的 `VARCHAR` 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度
      3.真正的难点在于：<font color=red>`要选择足够长的前缀以保证较高的选择性，同时又不能太长， 前缀的长度应该使前缀索引的选择性接近索引整个列，即前缀的基数应该接近于完整列的基数`</font>
3. 索引的数据结构

   索引的数据结构使用的是B+树，那为什么使用B+树而不是二叉查找树、平衡二叉树或者B树呢，接下来，我们来讲讲B+树的由来。

   ##### 二叉查找树

   它的特点：

   > 1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
   > 2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   > 3. 它的左、右子树也分别为二叉查找树。

   二叉查找树的特点就是为了保证每次查找都可以这折半而减少IO次数，但是二叉树就很考验第一个根节点的取值，因为很容易在这个特点下出现我们并发想发生的情况“树不分叉了”，这是我们不想见到的。

   ##### 二叉平衡树

   平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

   使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。

   就这个特点来看，可能各位会觉得这就很好，可以达到二叉树的理想的情况了。然而依然存在一些问题：

   > 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。（1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s）
   >
   > 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。

   ##### B树：改造二叉平衡

   对于二叉平衡树，我们更希望出现‘矮胖’树而不是‘瘦高’树，因为这样可以减少查询时的IO操作次数，增加查询效率。那么我们如何能够降低树的高度呢？

   假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）

   因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。

   ![img](https://img-blog.csdnimg.cn/1edcf35f41bd4baf8f8b3a29eab6d548.png)

   这种数据结构我们称为B树，B树是一种多叉平衡查找树，主要特点如下：

   > 1. B树的节点中存储着多个元素，每个内节点有多个分叉。
   > 2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
   > 3. 父节点当中的元素不会出现在子节点中。
   > 4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

   到这里，B树已经是比较理想的了，但我们还有可以优化的地方：

   > B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
   >
   > 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

   ##### B+树：改造B树

   B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于**非叶子节点是否存储数据**的问题

   > - B树：非叶子节点和叶子节点都会存储数据。
   > - B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

   ![img](https://img-blog.csdnimg.cn/8a0e2789eb3b491286cdd287fc89fe23.png)

   B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，所以放索引的磁盘块锁存放的索引数量是会跟这增加的，所以相对于B树来说，B+树的树高理论上情况下是比B树要矮的。也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。
   ##### HASH索引
   哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
   ![image-20230221202122041](C:\Users\luozh\AppData\Roaming\Typora\typora-user-images\image-20230221202122041.png)

4. MySQL索引的优化

   - 避免回表

     在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？

     使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby…）

     如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。

     **这就是一个典型的使用覆盖索引的优化策略减少回表的情况。**

   - 联合索引的使用

     联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。

     联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那建议这种情况下使用联合索引。

     **联合索引的使用：**

     > 1. 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
     > 2. 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。

## 优化手段

1. SQL优化

   - 避免SELECT * ，只查询需要的字段。

   - 写完SQL先explain查看执行计划

   - 操作delete或者update语句，加个limit

     - **「降低写错SQL的代价」**, 你在命令行执行这个SQL的时候，如果不加limit，执行的时候一个**「不小心手抖」**，可能数据全删掉了，如果**「删错」**了呢？加了limit 200，就不一样了。删错也只是丢失200条数据，可以通过binlog日志快速恢复的。
     - **「SQL效率很可能更高」**，你在SQL行中，加了limit 1，如果第一条就命中目标return， 没有limit的话，还会继续执行扫描表。
     - **「避免了长事务」**，delete执行时,如果age加了索引，MySQL会将所有相关的行加写锁和间隙锁，所有执行相关行会被锁住，如果删除数量大，会直接影响相关业务无法使用。
     - **「数据量大的话，容易把CPU打满」** ,如果你删除数据量很大时，不加 limit限制一下记录数，容易把cpu打满，导致越删越慢的。

   - 变更SQL操作先在测试环境执行，写明详细的操作步骤以及回滚方案，并在上生产前review。

   - 小表驱动大表是，即小的数据集驱动大的数据集：

     - 当B表的数据集比A表小时，用in优化 exist两表执行顺序是先查B表再查A表查询语句：SELECT * FROM A WHERE id in (SELECT id FROM B) ;
     - 当A表的数据集比B表小时，用exist优化in ，两表执行顺序是先查A表，再查B表，查询语句：SELECT * FROM A WHERE EXISTS (SELECT id FROM B WHERE A.id = B.ID) ;
     - 尽量使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表

   -  写完SQL语句，检查where,order by,group by后面的列，多表关联的列是否已加索引，优先考虑组合索引。

     - 反例

       ![img](https://pic1.zhimg.com/80/v2-2c17bb24ec3277f2d99ae1bacb78d8e4_720w.webp)

     - 正例

       > ```添加索引
       > 添加索引
       > alter table user add index idx_address_age (address,age)
       > ```

       ![img](https://pic4.zhimg.com/80/v2-16ec32fe1b4090bf69aad00deb0486bf_720w.webp)

   - 修改或删除重要数据前，要先备份，先备份，先备份

   - where后面的字段，留意其数据类型的隐式转换

     `字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较，最后导致索引失效`

   - 尽量使用varchar代替 char

     - 因为首先变长字段存储空间小，可以节省存储空间
     - 其次对于查询来说，在一个相对较小的字段内搜索，效率更高

   - SQL修改数据，养成begin + commit 事务的习惯

   - WHERE从句中不对列进行函数转换和表达式计算

2. SQL的一些优雅习惯

   1. 设计表的时候，所有表和字段都添加相应的注释（SQL规范优雅）

      `这个好习惯一定要养成啦，设计数据库表的时候，所有表和字段都添加相应的注释，后面更容易维护。`

   2. SQL书写格式，关键字大小保持一致，使用缩进。

   3. INSERT语句标明对应的字段名称

   4. 设计数据库表的时候，加上三个字段：主键，create_time,update_time。

   5. 所有表必须使用Innodb存储引擎

   6. 数据库和表的字符集统一使用UTF8

   7. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释

   8. 索引命名要规范，主键索引名为 pk_ 字段名；唯一索引名为 uk _字段名 ；普通索引名则为 idx _字段名

3. 优化索引的使用

   - 尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。
   - 不做列运算，把计算都放入各个业务系统实现
   - 查询语句尽可能简单，大语句拆小语句，减少锁时间
   - or 查询改写成 union 查询
   - 不用函数和触发器
   - 避免 %xx 查询，可以使用：select * from t where reverse(f) like reverse(’%abc’);
   - 少用 join 查询
   - 使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123
   - 尽量避免在 where 子句中使用 != 或者 <> 操作符，查询引用会放弃索引而进行全表扫描
   - 列表数据使用分页查询，每页数据量不要太大
   - 避免在索引列上使用 is null 和 is not null

4. 表结构设计优化

   - 使用可以存下数据最小的数据类型。
   - 尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。
   - 尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。数字可以默认 0 ，字符串默认 “”
   - 尽量少用 text 类型，非用不可时最好独立出一张表。
   - 尽量使用 timestamp，而非 datetime。
   - 单表不要有太多字段，建议在 20 个字段以内。

5. 如果以上优化还有问题，可以使用 show profiles 分析 sql

   1. show profiles

   2. show profile for query [queryId]

      ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mODlkZDliMy1hZmY2LTRjYjgtYjUyMy03ZjU2NDM2ZGYzZTcucG5n?x-oss-process=image/format,png)

      - show profile 返回结果字段含义

        1. Status ： sql 语句执行的状态

           status出现以下情况的建议

           - System lock

             > 确认是由于哪个锁引起的，通常是因为MySQL或InnoDB内核级的锁引起的。`建议`：如果耗时较大再关注即可，一般情况下都还好

           - Sending data

             > 解释：从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见。
             > 备注：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net。建议：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量

           - Sorting result

             > 正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序。
             > `建议`：创建适当的索引

           - Table lock

             > 表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表

           - create sort index

             > 当前的SELECT中需要用到临时表在进行ORDER BY排序
             > `建议`：创建适当的索引

           - createing tmp table

             > 创建临时表。先拷贝数据到临时表，用完后再删除临时表。消耗内存，数据来回拷贝删除，消耗时间，`建议`：优化索引

           - converting HEAP to MyISAM

             > 查询结果太大，内存不够，数据往磁盘上搬了。`建议`：优化索引，可以调整max_heap_table_size

           - Copying to tmp table on disk

             > 把内存中临时表复制到磁盘上，危险！！！`建议`：优化索引，可以调整tmp_table_size参数，增大内存临时表大小

        2. Duration: sql 执行过程中每一个步骤的耗时

        3. CPU_user: 当前用户占有的 cpu

        4. CPU_system: 系统占有的 cpu

        5. Block_ops_in : I/O 输入

        6. Block_ops_out : I/O 输出

      - show profile type 选项

        1. all：显示所有的性能开销信息
           block io：显示块 IO 相关的开销信息
           context switches: 上下文切换相关开销
           cpu：显示 CPU 相关的信息
           ipc：显示发送和接收相关的开销信息
           memory：显示内存相关的开销信息
           page faults：显示页面错误相关开销信息
           source：显示和 Source_function、Source_file、Source_line 相关的开销信息
           swaps：显示交换次数的相关信息

## 三范式

第一范式：每个表的每一列都要保持它的原子性，也就是表的每一列是不可分割的；

第二范式：在满足第一范式的基础上，每个表都要保持唯一性，也就是表的非主键字段完全依赖于主键字段；

第三范式：在满足第一范式和第二范式的基础上，表中不能产生传递关系，要消除表中的冗余性；

### 范式的优缺点

1. 优点
   - 范式化的更新操作通常比反范式化要快；
   - 当数据较好地范式化后，就只有很少或者没有重复数据，所以只需要修改更少的数据；
   - 范式化的表通常更小，可以更好地存放在内存中，执行操作更快；
   - 很少有冗余的数据，意味着检索数据时更少使用distinct或group by语句；
2. 缺点
   - 查询时，由于分表的原因，常常需要表关联；
   - 可能无法触发索引；

### 反范式的优缺点

1. 优点
   - 由于都在一个表里，可以减少表关联查询；
   - 可能同属于一个索引的字段，不用分表，触发索引更方便；
2. 缺点
   - 存储过多的冗余数据
   - 查询时可能需要distinct或group by的情况更多；
   - 在实际的开发中，都是混用范式化和反范式化，有的时候必要的冗余，有益而无害。

## 事务的四个特性

1. **原子性**：一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性

2. **一致性**：事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

   如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态

3. **隔离性**：

   事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。

   在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化

   1. 读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取

   2. 授权读取也称为已提交读（Read Commited），授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。

   3. 可重复读（Repeatable Read)

      就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；

   4. 串行化

      是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。

4. **持久性**：

   一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态

## MYSQL explain 详解
explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。
1. id SELECT识别符。这是SELECT查询序列号。

2. select_type 有以下几种值
    - simple 它表示简单的select,没有union和子查询
    - primary 最外面的select,在有子查询的语句中，最外面的select查询就是primary
    - union union语句的第二个或者说是后面那一个.
        `explain select  *  from uchome_space limit 10 union select * from uchome_space limit 10,10`
    - dependent union  UNION中的第二个或后面的SELECT语句，取决于外面的查询
    - union result  UNION的结果
    
3. table 输出的行所用的表，这个参数显而易见，容易理解

4. type 连接类型。有多个参数，先从最佳类型到最差类型介绍**重要且困难**
    - system 表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计
    - const 表最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快记住一定是用到primary key 或者unique，并且只检索出两条数据的 情况下才会是const,看下面这条语句
    - eq_ref 对于eq_ref的解释，mysql手册是这样说的:"对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY"。看下面的语句
    `explain select * from uchome_spacefield,uchome_space where uchome_spacefield.uid = uchome_space.uid`
    - ref 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。
    - ref_of_null 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。
    - index_merge 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。
    - unique_subquery
    - index_subquery
    - range 给定范围内的检索，使用一个索引来检查行。看下面两条语句
    `explain select * from uchome_space where uid in (1,2)`
    `xplain select * from uchome_space where groupid in (1,2)`
    uid有索引，groupid没有索引，结果是第一条语句的联接类型是range,第二个是ALL.以为是一定范围所以说像 between也可以这种联接,很明显
    - index 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
    - ALL 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记 const的表，这通常不好，并且通常在它情况下 很差。通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。
    
5. possible_keys 提示使用哪个索引会在该表中找到行，不太重要

6. keys MYSQL使用的索引，简单且重要

7. key_len MYSQL使用的索引长度

8. ref ref列显示使用哪个列或常数与key一起从表中选择行。

9. rows 显示MYSQL执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引

10. Extra 该列包含MySQL解决查询的详细信息。
    - Distinct MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。一直没见过这个值
    - Not exists
    - range checked for each record 没有找到合适的索引
    - using filesort 
    - using index 只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的信息。这个比较容易理解，就是说明是否使用了索引
    - using temporary 为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。
    - using where WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。（这个说明不是很理解，因为很多很多语句都会有where条件，而type为all或index只能说明检索的数据多，并不能说明错误，useing where不是很重要，但是很常见）
    - using sort_union(...), using union(...), using intersect(...) 这些函数说明如何为index_merge联接类型合并索引扫描
    - using index for group-by 类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。
    
11. 为什么不建议使用外键
    
    > 在早期的数据库表结构设计中，往往会把一张表引用另外一张表的字段（通常是 id）作为外键，借助 MySQL 自动维护外键，确实能够省掉很多开发工作，但是外键实际的代价不低，很多数据表设计规范已经明确禁止使用外键。
    
    外键并不是没有代价的。事实上，外键通常会需要服务器地在更改数据的时候检查另一张表。尽管 InnoDB 使用了索引提高这个操作速度，但并没有让数据检查的影响消失。甚至还可能产生一个很大的没有筛选性的索引。
    当然，外键在某些情况也能够改善性能。如果我们需要保证两个关联表的数据必须保持一致的时候，使用 MySQL 服务器进行检测会比程序来检测效率更高。外键在那种`级联删除`或更新的场合也很有用。但是这类操作是逐行进行的，因此会比批量删除或批量操作更慢。
    
    > 从众多互联网企业的数据库设计规范来看，外键是一再被重申要被禁用的。不单单是性能问题，而且互联网的业务多变，如果是表结构发生变动，很可能会导致外键关联的表出现意想不到的问题。因此，在非必要的情况下不要用外键，除非你只是为了验证外键的功能。
